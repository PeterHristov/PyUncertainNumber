PyUncertainNumber.UC.utils
==========================

.. py:module:: PyUncertainNumber.UC.utils


Classes
-------

.. autoapisummary::

   PyUncertainNumber.UC.utils.EnhancedJSONEncoder
   PyUncertainNumber.UC.utils.PBAEncoder
   PyUncertainNumber.UC.utils.UNEncoder


Functions
---------

.. autoapisummary::

   PyUncertainNumber.UC.utils.plot_ecdf
   PyUncertainNumber.UC.utils.to_database
   PyUncertainNumber.UC.utils.cd_root_dir
   PyUncertainNumber.UC.utils.initial_list_checking
   PyUncertainNumber.UC.utils.bad_list_checking
   PyUncertainNumber.UC.utils.PlusMinus_parser
   PyUncertainNumber.UC.utils.parser4
   PyUncertainNumber.UC.utils.percentage_finder
   PyUncertainNumber.UC.utils.percentage_converter
   PyUncertainNumber.UC.utils.get_concise_repr
   PyUncertainNumber.UC.utils.array2list
   PyUncertainNumber.UC.utils.entries_to_remove


Module Contents
---------------

.. py:function:: plot_ecdf(s, **kwargs)

   plot the CDF

   :param s: sample


.. py:function:: to_database(dict_list, db_name, col_name)

.. py:function:: cd_root_dir(depth=0)

.. py:function:: initial_list_checking(text)

   detects if a string representation of a list


.. py:function:: bad_list_checking(text)

   detects if a syntactically wrong specification of a list


.. py:function:: PlusMinus_parser(txt)

.. py:function:: parser4(text)

.. py:function:: percentage_finder(txt)

.. py:function:: percentage_converter(txt)

   convert a percentage into a float number

   .. note:: force only 1 percentage


.. py:class:: EnhancedJSONEncoder(*, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)

   Bases: :py:obj:`json.JSONEncoder`


   a template for jsonify general (dataclass) object

   #TODO Interval object in not json serializable


   .. py:method:: default(o)

      Implement this method in a subclass such that it returns
      a serializable object for ``o``, or calls the base implementation
      (to raise a ``TypeError``).

      For example, to support arbitrary iterators, you could
      implement default like this::

          def default(self, o):
              try:
                  iterable = iter(o)
              except TypeError:
                  pass
              else:
                  return list(iterable)
              # Let the base class default method raise the TypeError
              return JSONEncoder.default(self, o)




.. py:class:: PBAEncoder(*, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)

   Bases: :py:obj:`json.JSONEncoder`


   a bespoke JSON encoder for the PBA object


   .. py:method:: default(o)

      Implement this method in a subclass such that it returns
      a serializable object for ``o``, or calls the base implementation
      (to raise a ``TypeError``).

      For example, to support arbitrary iterators, you could
      implement default like this::

          def default(self, o):
              try:
                  iterable = iter(o)
              except TypeError:
                  pass
              else:
                  return list(iterable)
              # Let the base class default method raise the TypeError
              return JSONEncoder.default(self, o)




.. py:class:: UNEncoder(*, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)

   Bases: :py:obj:`json.JSONEncoder`


   a bespoke JSON encoder for the UncertainNumber object

   .. note::

      - Currently I'm treating the JSON data represent of a UN object
      the same as the __repr__ method. But this can be changed later on to
      show more explicitly the strucutre of pbox or distribution
      # TODO prettify the JSON output to be explicit
      e.g. 'essence': 'interval', 'interval_initialisation': [2, 3] to shown as 'interval' with lower end and upper end
      distribution to shown as the type and parameters; e.g. 'distribution': 'normal', 'parameters': [2, 3]


   .. py:method:: default(o)

      Implement this method in a subclass such that it returns
      a serializable object for ``o``, or calls the base implementation
      (to raise a ``TypeError``).

      For example, to support arbitrary iterators, you could
      implement default like this::

          def default(self, o):
              try:
                  iterable = iter(o)
              except TypeError:
                  pass
              else:
                  return list(iterable)
              # Let the base class default method raise the TypeError
              return JSONEncoder.default(self, o)




.. py:function:: get_concise_repr(a_dict)

.. py:function:: array2list(a_dict)

   convert an array from a dictionary into a list


.. py:function:: entries_to_remove(remove_entries, the_dict)

