PyUncertainNumber.UP.subinterval
================================

.. py:module:: PyUncertainNumber.UP.subinterval


Attributes
----------

.. autoapisummary::

   PyUncertainNumber.UP.subinterval.f
   PyUncertainNumber.UP.subinterval.x_bounds
   PyUncertainNumber.UP.subinterval.n
   PyUncertainNumber.UP.subinterval.y


Functions
---------

.. autoapisummary::

   PyUncertainNumber.UP.subinterval.cartesian
   PyUncertainNumber.UP.subinterval.subinterval_method


Module Contents
---------------

.. py:function:: cartesian(*arrays)

   Computes the Cartesian product of multiple input arrays

   :param - *arrays: Variable number of np.arrays representing the sets of values for each dimension.

   signature:
      - cartesian(*x:np.array)  -> np.ndarray

   .. note:: - The data type of the output array is determined based on the input arrays to ensure compatibility.

   :returns:

             A NumPy array where each row represents one combination from the Cartesian product.
                       The number of columns equals the number of input arrays.
   :rtype: - darray

   .. rubric:: Example

   x = np.array([1, 2], [3, 4], [5, 6])
   y = cartesian(*x)
   # Output:
   # array([[1, 3, 5],
   #        [1, 3, 6],
   #        [1, 4, 5],
   #        [1, 4, 6],
   #        [2, 3, 5],
   #        [2, 3, 6],
   #        [2, 4, 5],
   #        [2, 4, 6]])


.. py:function:: subinterval_method(x: numpy.ndarray, f: Callable, n: numpy.array, save_raw_data='no')

   Performs uncertainty propagation using the Subinterval Reconstitution Method.

   :param - x: A 2D NumPy array where each row represents an input variable and the two columns
               define its lower and upper bounds (interval).
   :param - f: A callable function that takes a 1D NumPy array of input values and returns the
               corresponding output(s).
   :param - n: A scalar (integer) or a 1D NumPy array specifying the number of subintervals for
               each input variable.
                - If a scalar, all input variables are divided into the same number of subintervals.
                - If an array, each element specifies the number of subintervals for the
                  corresponding input variable.
   :param - save_raw_data: Controls the amount of data returned:
                           - 'no': Returns only the minimum and maximum output values along with the
                                  corresponding input values.
                           - 'yes': Returns the above, plus the full arrays of unique input combinations
                                    (`all_input`) and their corresponding output values (`all_output`).

   signature:
       subinterval_method(x:np.ndarray, f:Callable, n:np.array, save_raw_data = 'no') -> np.ndarray

   .. note::

      - The function assumes that the intervals in `x` represent uncertainties with some
        form of distribution (not necessarily uniform) and aims to provide conservative
        bounds on the output uncertainty.
      - The computational cost increases exponentially with the number of input variables
        and the number of subintervals per variable.
      - If the `f` function returns multiple outputs, the `all_output` array will be 2-dimensional.

   :returns:

             A dictionary containing the results:
                 - 'min': A dictionary for lower bound results (if f in not None)
                     - 'x': Input values that produced the miminum output value(s) (if f is not None).
                     - 'f': Minimum output value(s) (if f is not None).
                 - 'max':  A dictionary for upper bound results (if f in not None)
                     - 'x': Input values that produced the maximum output value(s) (if f is not None).
                     - 'f': Maximum output value(s) (if f is not None).
                 - 'raw_data': A dictionary containing raw data (if save_raw_data is 'yes'):
                     - 'x': All generated input samples.
                     - 'f': Corresponding output values for each input sample.
   :rtype: - dict

   .. rubric:: Example

   #Define input intervals
   x = np.array([[1, 2], [3, 4], [5, 6]])

   # Define the function
   f = lambda x: x[0] + x[1] + x[2]

   # Run sampling method with n = 2
   y = subinterval_method(x, f, n, save_raw_data = 'yes')

   # Print the results
   print("-" * 30)
   print("Minimum:")
   print("x:", y['min']['x'])
   print("f:", y['min']['f'])

   print("-" * 30)
   print("Maximum:")
   print("x:", y['max']['x'])
   print("f:", y['max']['f'])

   print("-" * 30)
   print("Raw data")
   print("x:",y['raw_data']['x'])
   print("type_x:",type(y['raw_data']['x']))
   print("f:", y['raw_data']['f'])


.. py:data:: f

.. py:data:: x_bounds

.. py:data:: n
   :value: 2


.. py:data:: y

