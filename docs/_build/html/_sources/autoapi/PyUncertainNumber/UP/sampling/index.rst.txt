PyUncertainNumber.UP.sampling
=============================

.. py:module:: PyUncertainNumber.UP.sampling


Functions
---------

.. autoapisummary::

   PyUncertainNumber.UP.sampling.sampling_method


Module Contents
---------------

.. py:function:: sampling_method(x: numpy.ndarray, f: Callable, n: int, method='monte_carlo', endpoints=False, save_raw_data='no')

   Performs uncertainty propagation through sampling-based methods.

   :param x: A 2D NumPy array where each row represents an input variable and
             the two columns define its lower and upper bounds (interval).
   :type x: np.ndarray
   :param f: A callable function that takes a 1D NumPy array of input values and returns the
             corresponding output(s). Can be None, in which case only samples are generated.
   :type f: Callable
   :param n: The number of samples to generate for the chosen sampling method.
   :type n: int
   :param method:
                  The sampling method to use. Choose from:
                   - 'monte_carlo': Monte Carlo sampling (random sampling from uniform distributions)
                   - 'lhs': Latin Hypercube sampling (stratified sampling for better space coverage)
                  Defaults to 'montecarlo'.
   :type method: str, optional
   :param endpoints: If True, include the interval endpoints in the sampling.
                     Defaults to False. (Implementation not provided)
   :type endpoints: bool, optional
   :param save_raw_data: Whether to save raw data. Options: 'yes', 'no'.
                         Defaults to 'no'.
   :type save_raw_data: str, optional

   signature:
       sampling_method(x:np.ndarray, f:Callable, n:int, method ='montecarlo', endpoints=False, save_raw_data = 'no') -> dict of np.ndarrays

   .. note::

      - The function assumes that the intervals in `x` represent uniform distributions.
      - The implementation for including endpoints (`endpoints=True`) is not provided and needs to be added based on specific requirements.
      - If the `f` function returns multiple outputs, the `all_output` array will be 2-dimensional y and x for all x samples.

   :returns:

             A dictionary containing the results:
                 - 'min': A dictionary for lower bound results (if f in not None)
                     - 'x': Input values that produced the miminum output value(s) (if f is not None).
                     - 'f': Minimum output value(s) (if f is not None).
                 - 'max':  A dictionary for upper bound results (if f in not None)
                     - 'x': Input values that produced the maximum output value(s) (if f is not None).
                     - 'f': Maximum output value(s) (if f is not None).
                 - 'raw_data': A dictionary containing raw data (if save_raw_data is 'yes'):
                     - 'x': All generated input samples.
                     - 'f': Corresponding output values for each input sample.
   :rtype: dict

   .. rubric:: Example

   #Define input intervals
   x = np.array([[1, 2], [3, 4], [5, 6]])

   # Define the function
   f = lambda x: x[0] + x[1] + x[2]

   # Run sampling method with n = 5
   y = sampling_method(x, f, n=5, method='monte_carlo', endpoints=False, save_raw_data='no')

   # Print the results
   print("-" * 30)
   print("Minimum:")
   print("x:", y['min']['x'])
   print("f:", y['min']['f'])

   print("-" * 30)
   print("Maximum:")
   print("x:", y['max']['x'])
   print("f:", y['max']['f'])

   print("-" * 30)
   print("Raw data")
   print("x:",y['raw_data']['x'])
   print("type_x:",type(y['raw_data']['x']))
   print("f:", y['raw_data']['f'])


