PyUncertainNumber.UP.genetic_optimisation
=========================================

.. py:module:: PyUncertainNumber.UP.genetic_optimisation


Functions
---------

.. autoapisummary::

   PyUncertainNumber.UP.genetic_optimisation.a
   PyUncertainNumber.UP.genetic_optimisation.genetic_optimization_method
   PyUncertainNumber.UP.genetic_optimisation.main


Module Contents
---------------

.. py:function:: a(x)

.. py:function:: genetic_optimization_method(x_bounds: numpy.ndarray, f: Callable, pop_size=1000, n_gen=100, tol=0.001, n_gen_last=10, algorithm_type='NSGA2')

   :param x_bounds: Bounds for decision variables (NumPy array).
   :param f: Objective function to optimize.
   :param pop_size: Population size (int or array of shape (2,)).
   :param n_gen: Maximum number of generations (int or array of shape (2,)).
   :param tol: Tolerance for convergence check (float or array of shape (2,)).
   :param n_gen_last: Number of last generations to consider for convergence
                      (int or array of shape (2,)).
   :param algorithm_type: 'NSGA2' or 'GA' to select the optimization algorithm
                          (str or array of shape (2,)).

   signature:
       genetic_optimization_method(x_bounds: np.ndarray, f: Callable,
                                pop_size=1000, n_gen=100, tol=1e-3,
                                n_gen_last=10, algorithm_type="NSGA2") -> dict

   .. note:: Performs both minimization and maximization using a genetic algorithm.

   :returns:

             A dictionary containing the optimization results:
                   - 'min': A dictionary with keys 'x', 'f', 'n_gen', and 'n_iter' for minimization results.
                   - 'max': A dictionary with keys 'x', 'f', 'n_gen', and 'n_iter' for maximization results.
   :rtype: dict

   .. rubric:: Example

   # Example usage with different parameters for minimization and maximization
   f = lambda x: np.sum(x, axis=1)  # Example function
   x_bounds = np.array([[1, 2], [3, 4], [5, 6]])

   # Different population sizes for min and max
   pop_size = np.array([500, 1500])

   # Different number of generations
   n_gen = np.array([50, 150])

   # Different tolerances
   tol = np.array([1e-2, 1e-4])

   # Different algorithms
   algorithm_type = np.array(["GA", "NSGA2"])

   y = genetic_optimization_method(x_bounds, f, pop_size=pop_size, n_gen=n_gen,
                                   tol=tol, n_gen_last=10, algorithm_type=algorithm_type)

   print("-" * 30)
   print("Minimum:")
   print("Optimized x:", y['min']['x'])
   print("Optimized f:", y['min']['f'])
   print("Number of generations:", y['min']['n_gen'])
   print("Number of iterations:", y['min']['n_iter'])

   print("-" * 30)
   print("Maximum:")
   print("Optimized x:", y['max']['x'])
   print("Optimized f:", y['max']['f'])
   print("Number of generations:", y['max']['n_gen'])
   print("Number of iterations:", y['max']['n_iter'])


.. py:function:: main()

