import numpy as np

# Define the ranges
ranges = np.array([
    [-0.3, 492500, -0.24, 0.255, 0.637],
    [0.3, 507500, 0.24, 0.345, 0.763]
])

# Generate Cartesian product of ranges
Xcart = cartesian(ranges.T)  # Note the transpose (.T) to match MATLAB's behavior

d = Xcart.shape[1]  # Number of dimensions
inds = np.array([1] + [2**i + 1 for i in range(d)])  # Generate indices
Xeval = Xcart[inds - 1]  # Select rows based on indices (adjusting for 0-based indexing)

# Simulate xfoilrun (replace with your actual function)
clSign = np.zeros(len(inds))
cmSign = np.zeros(len(inds))
for i in range(len(inds)):
    xi = Xeval[i]
    # Replace the following line with your actual xfoilrun function call
    clSign[i], cmSign[i] = simulate_xfoilrun(xi)  

# Calculate signs
signXcl = np.sign(clSign[1:] - clSign[0])[::-1]  # Reverse to match MATLAB's flipud
signXcm = np.sign(cmSign[1:] - cmSign[0])[::-1]

# Calculate extreme points
XsignCl = extremePointX(ranges, signXcl)
XsignCm = extremePointX(ranges, signXcm)
Xsign = np.vstack([XsignCl, XsignCm])

# Simulate xfoilrun for bounding points
clBounds = np.zeros(2)
cmBounds = np.zeros(2)
for i in range(4):
    xi = Xsign[i]
    if i <= 1:
        # Replace the following line with your actual xfoilrun function call
        clBounds[i] = simulate_xfoilrun(xi)[0]  # Get only the first output (cl)
    else:
        # Replace the following line with your actual xfoilrun function call
        cmBounds[i-2] = simulate_xfoilrun(xi)[1]  # Get only the second output (cm)

# Print results
print("clBounds:", clBounds)
print("cmBounds:", cmBounds)