from pathlib import Path
import csv 
import pandas as pd
import numpy as np

def header_results(all_output:np.ndarray, all_input:np.ndarray):
    """ Generates generic header names for output and input dataframes.

    This function creates a list of column names suitable for a combined DataFrame 
    containing both output and input data. It dynamically generates header names based on 
    the shapes of the `all_output` and `all_input` NumPy arrays. 

    Args:
        all_output: A NumPy array representing the output data. It can be 1-dimensional or 
                2-dimensional. If 1D, it's assumed to represent a single output variable.
        all_input: A NumPy array representing the input data. It's assumed to be 2-dimensional, 
               where each row corresponds to a sample and each column represents an input variable.

    Returns:
        - A list of strings representing the header names. The first part of the list 
        contains headers for the output variables (e.g., 'y0', 'y1', ...), and the second
        part contains headers for the input variables (e.g., 'x0', 'x1', ...).
    """
    header = []

    for i in range(0, len(all_output[1])):
        output = "y" + str(i)
        header.append(output)
    for i in range(0, len(all_input[1])):
        Input = "x" + str(i)
        header.append(Input)

    return header

def create_folder(base_path, method):
    """Creates a folder named after the called UP method where the results files are stored

    args:
        - base_path: The base path
        - method: the name of the called method

    signature:
        create_folder(base_path: string, method: string ) -> path.folder

    note:
        - the augument `base_path` will specify the location of the created results folder.
        - the argument `method` will provide the name for the results folder. 

    return:
        -  A folder in a prespecified path
 
    example:
        base_path = "C:/Users/DAWS2_code/UP"
        method = "vertex"
        y = create_folder(base_path, method)
    """    
    base_path = Path(base_path)

    res_path = base_path / method
    res_path.mkdir(parents=True, exist_ok=True)

    return res_path

def create_csv(res_path, filename, data):
    """Creates a .csv file and sotres it in a pre-specified folder with results generated by a UP method

    args:
        - res_path: A folder in a prespecified path named after the called UP method
        - filename: the name of the file
        - data: a pandas.dataframe with results from UP method

    signature:
        create_csv(res_path = path, filename = filename, data = pandas.dataframe) -> path.filename

    note:
        - the augument `res_path` will specify the folder where the .csv file will be created.
        - argument `file` will provide the name of hte .csv file.
        - argument `data` will provide data in terms of pandas.dataframe.

    return:
        -  A .csv file in a prespecified folder 
 
    example:
        base_path = "C:/Users/DAWS2_code/UP/vertex"
        filename = 'min_max_values'
       df = pd.DataFrame(
         {"Name" : ["y0", "y0"],
          "fun"  : ["min","max"]
          "y0" : [4, 6]}, index = [1, 2, 3])
        header = ['Name', 'fun', 'values']
        y = create_csv(res_path, filename, df)
    """  
    try:
        # Attempt to open the file
        file_path = res_path / filename
        with open(file_path, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(data.columns)
            writer.writerows(data.values.tolist())
    except FileNotFoundError:
        print("The file does not exist.")

    return filename


def Upper_lower_values_with_input(df_OUTPUT_INPUT, i):
    # Removes possible NAN values from a given output QoI.
    # Estimates the min and max for each output QoI from the remaining non NAN values.
    # Creates a dataframe with the output-input for the min and max of each Qof.
    ## Issues: if more than one combinations produce min/max it canot be recorded.
    ## if some variables are responsible for one QoI and not hte others it cannot be accounted for
    y = df_OUTPUT_INPUT[df_OUTPUT_INPUT.columns[i]]

    # create a data.frame with one Qof and input
    x = df_OUTPUT_INPUT.filter(regex="x")

    filtered_df = pd.concat([y, x], axis=1)

    filtered_df_OUTPUT_INPUT = filtered_df[filtered_df.iloc[:, 0].notnull()]
    yint = [
        min(filtered_df_OUTPUT_INPUT.iloc[:, 0]),
        max(filtered_df_OUTPUT_INPUT.iloc[:, 0]),
    ]

    dat_ymin = filtered_df_OUTPUT_INPUT[filtered_df_OUTPUT_INPUT.iloc[:, 0] == yint[0]]
    dat_ymax = filtered_df_OUTPUT_INPUT[filtered_df_OUTPUT_INPUT.iloc[:, 0] == yint[1]]

    y_dat_com = pd.concat([dat_ymin, dat_ymax])
    y_dat_com = y_dat_com.drop_duplicates(subset=[y_dat_com.columns[0]], keep="first")
    y_dat_com = y_dat_com.rename(columns={y_dat_com.columns[0]: "y"})

    y_dat_com.insert(0, "Name", df_OUTPUT_INPUT.columns[i])
    y_dat_com.insert(1, "fun", ["min", "max"])

    return y_dat_com

def post_processing(all_input:np.ndarray, all_output:np.ndarray, res_path):
    
    """Post processing the results of a UP method

    args:
        - all_input: A NumPy array containing the input values used in the UP method.
        - all_output: A NumPy array containing the corresponding output values from the UP method.
        - res_path: The path to the directory where the results will be saved.

    signature:
        post_processing(all_input:np.ndarray, all_output:np.ndarray, res_path: path ) -> pandas.DataFrame

    note:
        - the augument `df_OUTPUT_INPUT` will specify pandas.dataframe of the min-max values for each output 
        - arguement `res_path` will provide the location of the directory of the results. 

    return:
        - df_output_input: A pandas DataFrame containing the combined output and input data.
        - Creates "Raw_data.csv" in `res_path` containing the raw output and input data.
        - Creates "NAlog.csv" in `res_path` if any NaN values are present in the output, 
          logging the corresponding input values.
        - Prints a message if no NaN values are found.


    example:
        df = pd.DataFrame(
         {"y0" : [4, 5, 5, 6],
          "x0" : [1, 2, 1, 2],
          "x1" : [3, 3, 4, 4]}, index = [1, 2, 3])
        res_path = "C:/Users/DAWS2_code/UP/vertex"
        y = post_processing(df, res_path)

    # TODO create a .csv with all min,max and associated x values ...
    # units ...
    # fields: None...
    """     
    # Transform np.array input-output into pandas data.frame 
    df_input = pd.DataFrame(all_input)
    df_output = pd.DataFrame(all_output)
    # Create a single output input data.frame
    df_output_input = pd.concat([df_output, df_input], axis=1)
    # determine generic header for output and input
    header = header_results(all_output, all_input)
    df_output_input.columns = header
    #header = df_output_input.columns.values.tolist()
    
    # Return .csv with raw data only if asked ###
    create_csv(res_path, "Raw_data.csv", df_output_input)

    # if NA output create a log file with the input which caused these values.
    df_NA = df_output_input[df_output_input.isna().any(axis=1)]
    if len(df_NA) != 0:
        # The input values are rounded to ensure equality
        df_NA = df_NA.apply(np.round, args=[4])
        df_NA_unique = df_NA.drop_duplicates(keep="first", ignore_index=True)

        create_csv(res_path, "NAlog.csv", df_NA_unique)
    else:
        print("There are no NA values produced by the input")
     

  #       df_NA_unique = NA_values_with_input(df_output_input, res_path)
   #  else:
   #      print("Warning: NA values are produced with given input")

   #  # min-max of all output QoI and corresponding input values
   #  y_dat_all = []

   #  for i in range(sum("y" in s for s in header)):
   #      for j in range(2):
   #          y_dat = Upper_lower_values_with_input(df_OUTPUT_INPUT, i)
   #          y_dat_all.append(y_dat.values.tolist()[j])

   #  df_y_dat_all = pd.DataFrame(y_dat_all)
   #  df_y_dat_all.columns = y_dat.columns

   #  create_csv(res_path, "min_max_input.csv", df_y_dat_all)

   #  # keep only y values
   #  min_max_y_values = df_y_dat_all[["Name", "fun", "y"]]

    return df_output_input #min_max_y_values

def NA_values_with_input(df_OUTPUT_INPUT, res_path):
   """Searching for NAN values in the output of a called UP method and create .csv file to store them.

    args:
        - df_OUTPUT_INPUT: a pandas.DataFrame containing output and associated input produced by UP method
        - res_path: The path, named after the UP method, where the results will be saved

    signature:
        post_processing(df_OUTPUT_INPUT: pandas.dataframe, res_path: path ) -> pandas.DataFrame

    note:
        - the augument `df_OUTPUT_INPUT` will specify pandas.dataframe of the min-max values for each output 
        - arguement `res_path` will provide the location of the directory of the results. 

    return:
        -  A .csv file to store possible NAN output values and their associated input values.

    example:
        df = pd.DataFrame(
         {"y0" : [4, 5, 5, 6],
          "x0" : [1, 2, 1, 2],
          "x1" : [3, 3, 4, 4]}, index = [1, 2, 3])
        res_path = "C:/Users/DAWS2_code/UP/vertex"
        y = post_processing(df, res_path)

    """     
   df_NA = df_OUTPUT_INPUT[df_OUTPUT_INPUT.isna().any(axis=1)]
   # The input values are rounded to ensure equality
   df_NA = df_NA.apply(np.round, args=[4])
   df_NA_unique = df_NA.drop_duplicates(keep="first", ignore_index=True)

   create_csv(res_path, "NAlog.csv", df_NA_unique, df_NA_unique.columns())

   return df_NA_unique

def post_processing_old(df_OUTPUT_INPUT, res_path):
    """Post processing the results of a UP method

    args:
        - df_OUTPUT_INPUT: a pandas.DataFrame containing output and associated input produced by UP method
        - res_path: The path, named after the UP method, where the results will be saved

    signature:
        post_processing(df_OUTPUT_INPUT: pandas.dataframe, res_path: path ) -> pandas.DataFrame

    note:
        - the augument `df_OUTPUT_INPUT` will specify pandas.dataframe of the min-max values for each output 
        - arguement `res_path` will provide the location of the directory of the results. 

    return:
        -  A pandas.Dataframe with the min-max for each output QoI
        -  A path, named after the called UP method 
        -  A warning if input values produce NAN output. 
        -  A .csv file to store a pandas dataframe of the raw results saved in the specified folder.
        -  A .csv file  to store the min/max output values and their associated input values. 

    example:
        df = pd.DataFrame(
         {"y0" : [4, 5, 5, 6],
          "x0" : [1, 2, 1, 2],
          "x1" : [3, 3, 4, 4]}, index = [1, 2, 3])
        res_path = "C:/Users/DAWS2_code/UP/vertex"
        y = post_processing(df, res_path)

    # TODO post-process the df into UN objects ...
    # units ...
    # fields: None...
    """     
    # header
    header = df_OUTPUT_INPUT.columns.values.tolist()

    # Return .csv with raw data only if asked ###
    create_csv(res_path, "Raw_data.csv", df_OUTPUT_INPUT)

    # if NA output create a log file with the input which caused these values.
    df_NA_unique = NA_values_with_input(df_OUTPUT_INPUT, res_path)
    if df_NA_unique.empty == True:
        print("NA values are NOT produced with given input")
    else:
        print("Warning: NA values are produced with given input")

    # min-max of all output QoI and corresponding input values
    y_dat_all = []

    for i in range(sum("y" in s for s in header)):
        for j in range(2):
            y_dat = Upper_lower_values_with_input(df_OUTPUT_INPUT, i)
            y_dat_all.append(y_dat.values.tolist()[j])

    df_y_dat_all = pd.DataFrame(y_dat_all)
    df_y_dat_all.columns = y_dat.columns

    create_csv(res_path, "min_max_input.csv", df_y_dat_all)

    # keep only y values
    min_max_y_values = df_y_dat_all[["Name", "fun", "y"]]
    
    return min_max_y_values

def post_process():
    pass